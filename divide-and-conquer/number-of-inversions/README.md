# 反転数

配列Aを渡された時に、`i < j`でありかつ`A[i] > A[j]`であるような`(i, j)`の組み合わせの数をカウントする

## 考え方

バブルソートを行って反転数を調べる方法では、`O(n^2)`のアルゴリズムとなってしまう

そこで、マージソートのmerge関数に少し処理を追加することで分割統治法を応用して実装することが可能

### 反転数の計算

配列の添字`k`について`k`より左側にあり`A[k]`より大きい値の数を`C[k]`とすると、`C[k]`の合計が配列Aの反転数となる

* A : [5 3 6 2 1 4]
* C : [0 1 0 3 4 2]

つまり、この場合は反転数10

### マージソートの考えの導入

リストを2つに分割し、それぞれで反転数を計算する。

次に、マージソートで整列済みの配列LとRをマージしつつ反転数を計算していく。

つまり、Rの要素がLの要素よりも左に移動するときに、各要素が飛ばしたLの要素が反転数である。

## 実行例
### 入力例

```
5
3 5 2 1 4
```

### 出力例

```
6
```