# ハッシュ

- 各要素の値に応じて格納場所を管理するハッシュテーブルを用いてデータの検索を高速化する
- キーを持つデータの集合に対して、次の操作を効率的に行うことができるデータ構造
  - 動的な挿入
  - 検索
  - 削除
- ハッシュテーブルはm個の要素を格納できる配列とデータのキーから配列の添字を決定する関数から構成される
  - 各データを挿入すべき位置を、そのデータのキーを入力とした関数で求める
- 衝突を無視すれば、`O(1)`で要素の挿入や検索を行うことが可能

## ハッシュの実装方法 (素朴な実装)

```go
package dictionary

type Data struct {
	key string
}

func h (key string) int
var T [1000]Data

func Insert(data Data) {
	T[h(data.key)] = data
}

func Search(data Data) Data {
	return T[h(data.key)]
}
```

- このkeyの値から配列Tの添字を求める関数をハッシュ関数とよび、それが返す値をハッシュ値と呼ぶ。
- ハッシュ関数は、ハッシュ値が0からm-1の値を取るように実装する
  
  `h(k) = k mod m`

- ただしこのままだと異なるkeyが同一のハッシュ値になる「衝突」が起きる可能性がある

## ハッシュの実装方法(オープンアドレス法)

- 衝突を解決する方法の1つ
- ダブルハッシュを用いたオープンアドレス法では、衝突した場合に第二のハッシュ関数を用いてハッシュ値を求める

  `H(k) = h(k, i) = (h1(k) + i * h2(k)) mod m`

- ハッシュ関数`h(k, i)`はキーkに加えて整数iを引数としていて、iは衝突が発生して次のハッシュ値を計算した回数を表す
- 最初の添字を`h1(k)`で求め、衝突が起きた場合に添字を`h2(k)`だけ移動して空いている位置を探していく

  `h1(k) = k mod 7; h2(k) = 1 + (k mod 6)`

- `h2(k)`分だけ添字を移動する際に`h2(k)`とTのサイズが互いに素でないと生成できない添字が出るため、mは素数として`h2(k)`をmより小さくするなどの工夫が考えられる
